# http协议

## 介绍

**超文本传输协议（HTTP）**是一个用于传输超媒体文档（例如 HTML）的**应用层协议**。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的传输层上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。[RUDP](https://en.wikipedia.org/wiki/Reliable_User_Datagram_Protocol)——作为 UDP 的可靠化升级版本——是一种合适的替代选择。

它不仅被用来传输**超文本文档**，还用来传输**图片**、**视频**或者向服务器发送如**HTML表单**这样的信息。HTTP还可以根据网页需求，仅获取部分Web文档内容更新网页。

## http流

当客户端想要和服务端进行信息交互时（服务端是指最终服务器，或者是一个中间代理），过程表现为下面几步：

1、打开一个TCP（传输层协议）连接：TCP连接被用来发送一条或多条请求，以及接受响应消息。客户端可能打开一条新的连接，或重用一个已经存在的连接，或者也可能开几个新的TCP连接连向服务端。

补充：在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接

2、发送一个HTTP报文：HTTP报文（在HTTP/2之前）是语义可读的。在HTTP/2中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。

```html
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```

![request-header](https://minio.lihuiwang.net/notes/notes/2023/09/10/http-1.png)

```shell
//表明该请求来源于 http://foo.exmaple
Origin: http://foo.example
```

3、读取服务端返回的报文信息：

```html
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
```

![response-header](https://minio.lihuiwang.net/notes/notes/2023/09/10/http-2.png)

```shell
//表明，该资源可以被任意外域访问
Access-Control-Allow-Origin: *   
//如果服务端仅允许来自 http://foo.example 的访问
Access-Control-Allow-Origin: http://foo.example 
```

4、关闭连接或者为后续请求重用连接。

当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的帧所取代。

## 缓存

1、类型

缓存的种类有很多,其大致可归为两类：私有（shared cache）与共享（local（private）cache）缓存。共享缓存存储的响应能够被多个用户使用

2、缓存控制---Cache-control头

- 禁止缓存

  缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。

  ```html
  Cache-Control: no-store
  ```

- 强制确认缓存

  如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。

  ```html
  Cache-Control: no-cache
  ```

- 私有缓存和公共缓存

  "public" 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了"public"，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。

  而 "private" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。

  ```html
  Cache-Control: private
  Cache-Control: public
  ```

- 缓存过期机制

  过期机制中，最重要的指令是 "`max-age=<seconds>`"，表示资源能够被缓存（保持新鲜）的最大时间。相对[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。

  ```html
  Cache-Control: max-age=31536000
  ```

- 缓存验证确认

  当使用了 "`must-revalidate`" 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。详情看下文关于[缓存校验](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ#Cache_validation)的内容。

  用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有"Cache-control: must-revalidate”的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置Advanced->Cache为强制验证缓存也能达到相同的效果。

  当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。

  ```html
  Cache-Control: must-revalidate
  ```

## http的发展

http/0.9:单行协议===>http/1.0:构建可拓展性===>http/1.1:标准化的协议===>http/2.0:新增首部压缩,新增服务端推送

## http优化方法

- 缓存资源

  更多地利用缓存资源，可以提高网站的性能和响应速度。