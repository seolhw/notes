 1、使用router = this.router.resolve({....})和window.open(router.href, '_blank')
新建标签页中打开新页面； 

~~~javascript
const router  = this.$router.resolve({
        name: 'frontRegister',
        query: {
          instituteId: this.formData.instituteId
        }
      })
window.open(router.href, '_blank')
~~~

2、利用a标签的target="_***"新建标签页中打开新页面；

~~~javascript
<a href="/register/registerListAll/frontRegister" target="_bank">1111111</a>
<a href="http://localhost:8085/reportTableManagement/financialStatistics" target="_a">哈哈</a>
~~~

## vue约定路由功能

准备工作：

1、mkdir vue-auto-router-cli:创建目录

2、cd vue-auto-router-cli：切换目录

3、npm init -y：初始化npm管理包

4、npm i commander download-git-repo ora handlebars -S：安装常用的包

第一步：把kkb命令和js文件连接起来

1、建立程序入口文件（bin=>kkb.js）

2、建立在全局可以执行的命令（package.json里进行配置）

~~~j
"bin": {
    "kkb": "./bin/kkb.js"
 }
~~~

3、在kkb.js里写内容

~~~javascript
#!/usr/bin/env node  //指定脚本脚本解释器的类型（用node运行js代码）
console.log('输入kkb,我就出现了')
~~~

4、npm link :把js文件链接到npm全局

5、输入kkb即可打印

至此完成了一个小的架构：把kkb命令连接到了js代码上

第二步：定制命令行界面（使用commander.js）如：输入kkb init filename 打印出 ‘初始化filename’

- kkb.js文件里

~~~javascript
#!/usr/bin/env node
const program = require('commander') //引入commander.js
program.version(require('../package').version) //指定版本
program
  .command('init <name>') //命令
  .description('init project') //描述
  .action(name => {
    console.log('初始化'+name) //执行该命令的回调
  })
program.parse(process.argv)//argv：所有的执行参数
~~~

- 编写init命令，优化打印

1、建立init命令文件（lib/init.js）

2、 yarn add figlet clear chalk ora open -S：安装所需要的包

在init.js文件里编写逻辑，优化打印（字体变大颜色变绿......）

~~~javascript
const { promisify } = require('util')
const figlet = promisify(require('figlet'))
const clear = require('clear')
const chalk = require('chalk')
const log=content=>console.log(chalk.green(content))
module.exports = async name => {
  //打印内容
  clear()//先清空所有命令行
  const data = await figlet(name)
  log(data)
}
~~~

把init.js引入kkb.js里

~~~javascript
#!/usr/bin/env node
const program = require('commander')
program.version(require('../package').version)
program
  .command('init <name>')
  .description('init project')
  // .action(name => {
  //   console.log('初始化'+name)
  // })
  /关键代码开始
  .action(require('../lib/init'))//引入init.js文件
  关键代码结束/
program.parse(process.argv)
~~~

第三步：克隆脚手架（kkb init clone）

1、新建clone.js文件，编写clone逻辑（把git上的脚手架项目克隆到本地的指定的文件夹里）

~~~javascript
const { promisify } = require('util')
module.exports.clone = async (repo, desc) => {
  const downLoad = promisify(require('download-git-repo'))//输入地址可以直接下载git项目
  const ora = require('ora')//进度条
  const process = ora(`下载...${repo}`)
  await downLoad(repo, desc)//下载
  process.succeed()//下载成功
}
~~~

2、把clone.js引入到init.js里

~~~javascript
const { promisify } = require('util')
const figlet = promisify(require('figlet'))
const clear = require('clear')
const chalk = require('chalk')
const log = content => console.log(chalk.green(content))
/关键代码开始
const {clone}=require('./clone')
 关键代码结束/
module.exports = async name => {
  //打印内容
  clear()//先清空所有命令行
  const data = await figlet(name)
  log(data)
  log('创建项目：' + name)
   /关键代码开始
  await clone('github:su37josephxia/vue-template',name)
   关键代码结束/
}
~~~

3、克隆脚手架之后，自动完成安装依赖

~~~javascript
const clear = require('clear')
const chalk = require('chalk')
const log = content => console.log(chalk.green(content))
const { clone } = require('./clone')
/关键代码
const spawn = async (...args) => {
  const { spawn } = require('child_process')//子进程
  return new Promise(resolve => {
    console.log(...args)
    const proc = spawn(...args)
    proc.stdout.pipe(process.stdout)//输出流
    proc.stderr.pipe(process.stderr)//错误流
    proc.on('close', () => { //子进程执行结束时
      resolve()
    })
  })
}
关键代码/
module.exports = async name => {
  //打印内容
  clear()//先清空所有命令行
  const data = await figlet(name)
  log(data)
  log('创建项目：' + name)
  await clone('github:su37josephxia/vue-template', name)
  /关键代码
  await spawn('yarn', ['install'], { cwd: `./${name}` ,shell:true})
  log('自动安装依赖已经完成，可启动项目')
  关键代码/
}
~~~

4、启动项目，自动在浏览器中打开

~~~javascript
const clear = require('clear')
const chalk = require('chalk')
const log = content => console.log(chalk.green(content))
const { clone } = require('./clone')
const spawn = async (...args) => {
  const { spawn } = require('child_process')//子进程
  return new Promise(resolve => {
    console.log(...args)
    const proc = spawn(...args)
    proc.stdout.pipe(process.stdout)//输出流
    proc.stderr.pipe(process.stderr)//错误流
    proc.on('close', () => { //子进程执行结束时
      resolve()
    })
  })
}
/关键代码
const open = require('open')
关键代码/
module.exports = async name => {
  //打印内容
  clear()//先清空所有命令行
  const data = await figlet(name)
  log(data)
  log('创建项目：' + name)
  await clone('github:su37josephxia/vue-template', name)
  await spawn('yarn', ['install'], { cwd: `./${name}` ,shell:true})
  /关键代码
  open('http://localhost:8080/')
  await spawn('yarn', ['serve'], { cwd: `./${name}` ,shell:true})
  关键代码/
}
~~~

第四步：vue约定路由功能

思路：（1）、读取views文件夹下的目录；（2）、通过读取的文件名自动生成路由

1、建立refresh指令文件

~~~javascript
const fs = require('fs')
const handlebars = require('handlebars')//编译模版
module.exports = async () => {
  //获取页面列表
  const list = fs.readdirSync('./src/views')
    .filter(v => v !== 'Home.vue')//剔除home页面
    .map(v => (
      {
        name: v.replace('.vue', '').toLowerCase(),
        file:v
      }
    ))
  console.log(list)
  //生成路由定义
  compile({ list }, './src/router.js', './template/router.js.hbs')
  //生成菜单
  compile({list},'./src/App.vue','./template/App.vue.hbs')
  /**
   * 编译模版文件
   * @param {*} meta 数据定义
   * @param {*} filePath 目标文件路径
   * @param {*} template 模版文件路径
   */
  function compile(meta, filePath, template) {
    if (fs.existsSync(template)) { //判断文件路径是否存在
      const content = fs.readFileSync(template).toString()//把模版读取成字符串
      const result = handlebars.compile(content)(meta)//把模版和数据整合在一起
      fs.writeFileSync(filePath, result)
      console.log('路由成功')
    }
  }
}
~~~

2、注册refresh指令(在kkb文件下)

~~~javascript
#!/usr/bin/env node
const program = require('commander')
program.version(require('../package').version)
program
  .command('init <name>')
  .description('init project')
  // .action(name => {
  //   console.log('初始化'+name)
  // })
  .action(require('../lib/init'))//引入init.js文件
/关键代码
program
  .command('refresh')
  .description('refresh routers')
  .action(require('../lib/refresh'))//引入refresh.js文件
关键代码/
program.parse(process.argv)
~~~

