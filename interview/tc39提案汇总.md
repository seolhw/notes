# `TC39`提案过程

TC39是为ES制定标准的国际组织，它的成员主要是由各大浏览器产商代表及一些一线互联网公司组成。规范定义了 JavaScript 如何一步一步的进化、发展。每年都会发布新版本，带来新的语法。所以作为一名js开发者，有必要关注一下TC39的提案。

TC39 提案过程分为 Stage 0 ~ 4，共 5 个阶段，分别代表：起草、提案、草案、候选、完成。

stage 0 ：任何TC39的成员都可以提交，只是一个提案的想法。

stage 1：进入此阶段就意味着这一提案被认为是正式的，需要对此提案的场景与API进行详尽的描述。

stage 2：这一阶段的提案如果能最终进入到标准，那么在之后的阶段都不会有太大的变化，因为理论上只接受增量修改。

Stage 3：所有的语法、`api`都完整实现。此时浏览器会开始实现这个标准，并接受用户反馈。这个阶段的提案文本只能针对用户反馈发现的问题进行修改。

statge 4：提案已经完成，会在下一次发布时成为ES标准的一部分。

## 近期关键提案汇总

### Stage 4

> Stage 4 的提案已经确认写入 ECMAScript 标准中，且至少有 2 个浏览器已经实现并通过测试。

#### exec

`TC39`链接https://github.com/tc39/proposal-regexp-match-Indices

介绍：目前我们想通过正则匹配来获取结果的开始位置和结束位置，并不是很方便。此时我们就可以使用正则实例的exec()方法来获取匹配的开始位置。此提案为`exec()`方法的返回结果加上`indices`属性，在这个属性上面可以拿到匹配的开始位置和结束位置。

~~~javascript
const text = 'zabbcdef';
const re = /ab/;
const result = re.exec(text);

result.index // 1
result.indices // [ [1, 3] ]
~~~

|                | TypeScript | Chrome | Firefox | Safari             |
| -------------- | ---------- | ------ | ------- | ------------------ |
| 落地时间版本号 | 4.5.4      | 91     | 88      | Technology Preview |

#### .hasOwn()

> `TC39`链接 https://github.com/tc39/proposal-accessible-object-hasownproperty

介绍：这个提案为 `Object` 添加了新的静态方法 `Object.hasOwn`，用这一静态方法可以直接判断某个字段是否存在于对象中。`Object.hasOwn`等于`Object.prototype.hasOwnProperty.call`。

~~~javascript
// 老写法
const object1 = Object.create(null)
console.log(object1.hasOwnProperty("foo")) // TypeError: obj1.hasOwnProperty is not a function

// 新写法
let object2 = Object.create(null)
Object.hasOwn(object2, "foo") // false
let object3 = { foo: false }
Object.hasOwn(object3, "foo") // true
~~~

|                | TypeScript | Chrome | Firefox | Safari             |
| -------------- | ---------- | ------ | ------- | ------------------ |
| 落地时间版本号 | 4.6.0      | 93     | 92      | Technology Preview |

#### 私有属性和私有方法 #

> `TC39`链接 https://github.com/tc39/proposal-private-methods,https://github.com/tc39/proposal-class-fields

介绍：此提案为`class`加了私有属性。方法是在属性名之前，使用`#`表示。只能在类的内部使用。如果在类的外部使用，就会报错。这种写法不仅可以写私有属性，还可以用来写私有方法。另外，私有属性也可以设置 getter 和 setter 方法。

~~~javascript
class IncreasingCounter {
  #count = 0;
  get value() {
    console.log('Getting the current value!');
    return this.#count;
  }
  increment() {
    this.#count++;
  }
}
const counter = new IncreasingCounter();
counter.#count // 报错
counter.#count = 42 // 报错
~~~

|                | TypeScript | Chrome | Firefox | Safari |
| -------------- | ---------- | ------ | ------- | ------ |
| 落地时间版本号 | 4          | 74     | 75      | 14.1   |

#### 静态属性 static

> `TC39`链接 https://github.com/tc39/proposal-static-class-features

介绍：静态属性指的是 Class 本身的属性，而不是定义在实例对象（`this`）上的属性。Class 内部只有静态方法，没有静态属性。类的静态属性，写法是在实例属性的前面，加上`static`关键字。

~~~javascript
// 老写法
class Foo {
  // ...
}
Foo.prop = 1;

// 新写法
class Foo {
  static prop = 1;
}
~~~

|                | TypeScript | Chrome | Firefox | Safari |
| -------------- | ---------- | ------ | ------- | ------ |
| 落地时间版本号 | 4          | 74     | 90      | 14.1   |

#### 静态块 static block

> `TC39`链接 https://github.com/tc39/proposal-class-static-block

介绍：我们在初始化一个依赖其他静态属性的静态属性时。要么写在类的外部，要么写在`constructor()`方法里面。这两种方法都不是很理想，前者是将类的内部逻辑写到了外部，后者则是每次新建实例都会运行一次。为了解决这个问题，故引入改提案，允许在类的内部设置一个代码块，在类生成时运行一次，主要作用是对静态属性进行初始化。

~~~javascript
// 老写法
class C {
  static x = 234;
  static y;
  static z;
}

try {
  const obj = doSomethingWith(C.x);
  C.y = obj.y
  C.z = obj.z;
} catch {
  C.y = ...;
  C.z = ...;
}

// 新写法
class C {
  static x = ...;
  static y;
  static z;

  static {
    try {
      const obj = doSomethingWith(this.x);
      this.y = obj.y;
      this.z = obj.z;
    }
    catch {
      this.y = ...;
      this.z = ...;
    }
  }
}
~~~

|                | TypeScript | Chrome | Firefox | Safari |
| -------------- | ---------- | ------ | ------- | ------ |
| 落地时间版本号 | 4          | 94     | 93      | X      |

### stage 3

#### at()

> `TC39`链接 https://github.com/tc39/proposal-relative-indexing-method

介绍：此方法接受一个整数作为参数，返回对应位置的成员，支持负索引。如果参数位置超出了数组范围，`at()`返回`undefined`

适用范围：数组、字符串、类型数组（TypedArray）

~~~javascript
const arr = [5, 12, 8, 130, 44];
//  老写法
arr[2] // 8
arr[arr.length-2] // 130

// 新写法
arr.at(2) // 8
arr.at(-2) // 130
~~~

#### findLast  findLastIndex

> `TC39`链接https://github.com/tc39/proposal-array-find-from-last

介绍：从数组**的最后一个到第一个**查找元素的方法,并返回整个数组中的最后一个匹配元素或索引。

~~~javascript
// 老写法
[...].reverse().find()
[...].length - 1 - [...].reverse().findIndex()

// 新写法
[...].findLast()
[...].findLastIndex()
~~~

### stage 2

> 这一部分的提案是待确定，很有可能实现的。反复横跳的事情时有发生，对于它们，可以先了解一下大致思路。

#### 装饰器 Decorator

> `TC39`链接https://github.com/tc39/proposal-decorators

介绍：曾经非常有潜力的装饰器提案，花了几年的时间大改才进展到 stage 2，被放弃后又被重新提出，目前又进展到 stage 2 了。目前还没有定案，不知道语法会不会再变。简单了解一下即可。装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。

~~~javascript
@testable
class MyTestableClass {
  // ...
}

function testable(target) {
  target.isTestable = true;
}

MyTestableClass.isTestable // true
~~~

上面代码中，`@testable`就是一个装饰器。它修改了`MyTestableClass`这个类的行为，为它加上了静态属性`isTestable`。`testable`函数的参数`target`是`MyTestableClass`类本身。

#### 管道运算符  |>

> `TC39`链接https://github.com/tc39/proposal-pipeline-operator

介绍：Unix 操作系统有一个管道机制（pipeline），可以把前一个操作的值传给后一个操作。这个机制非常有用，使得简单的操作可以组合成为复杂的操作。许多语言都有管道的实现，该提案，让 JavaScript 也拥有管道机制。JavaScript 的管道是一个运算符，写作`|>`。它的左边是一个表达式，右边是一个函数。管道运算符把左边表达式的值，传入右边的函数进行求值。

~~~javascript
function doubleSay (str) {
  return str + ", " + str;
}
function capitalize (str) {
  return str[0].toUpperCase() + str.substring(1);
}
function exclaim (str) {
  return str + '!';
}


// 传统的写法
exclaim(capitalize(doubleSay('hello')))
// "Hello, hello!"
// 管道的写法
'hello'
  |> doubleSay
  |> capitalize
  |> exclaim
// "Hello, hello!"
~~~

### stage 1

> 提案通常会在 Stage 1 停留几年，可能会有很多变化，也可能会随时被废弃。

#### ~()

> `TC39`链接https://github.com/tc39/proposal-partial-application

介绍：我们有时候，需要创建某些参数已经确定的函数，这一提案可以解决这种需求。

~~~javascript
// 老写法
function add(x, y) { return x + y; }

const addOne = add.bind(null, 1);
addOne(2); // 3

// 新写法
const add = (x, y) => x + y;

const addOne = add~(1, ?);
addOne(2); // 3

const addTen = add~(?, 10);
addTen(2); // 12
~~~

#### do

> `TC39`链接https://github.com/tc39/proposal-do-expressions

介绍：这样用三目非常麻烦，代码可读性很差，而用这种方式或者 switch 还是怎样都没办法在一个语句内完成，因此，引入 `do expression` 可以很好的解决这个问题。

~~~javascript
// 老代码
type Type = 'cat' | 'dog' | 'human';
const itemType: Type = '...';

let Component;
if (itemType === 'cat') {
    Component = Cat;
} else if (itemType === 'dog') {
    Component = Dog;
} else if (itemType === 'human') {
    Component = Human;
}
<Component />;

// 新代码
let Component = do {
    if (itemType === 'cat') Cat;
    else if (itemType === 'dog') Dog;
    else if (itemType === 'human') Human;
};
return <Component />;
~~~

#### promise.try()

`TC39`链接https://github.com/tc39/proposal-promise-try

介绍：实际开发中，经常遇到一种情况：不知道或者不想区分，函数`f`是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管`f`是否包含异步操作，都用`then`方法指定下一步流程，用`catch`方法处理`f`抛出的错误。

~~~javascript
// 老写法
const f = () => console.log('now');
(async () => f())();
console.log('next');

// 新写法
const f = () => console.log('now');
Promise.try(f);
console.log('next');
~~~

## 2021提案汇总

1. **replaceAll ：**和replace使用方法相同，区别是如果第一个参数是字符串，那么是会替换所有匹配的字符。

2. **Promise.any：**如果参数中有一个promise的状态变成了fullfilled，那Promise.any的状态就会变成fullfilled。

3. **WeakRefs：**WeakRefs是一个Class，提案上说一般和FinalizationRegistry Class配合使用，并且一般开发者尽量避免使用。

4. **逻辑运算符：**新增??=和||=、&&=三个赋值操作符 。

   ​     ??= 的意思是，如果左侧的值是空值（null和undefined），那么就把右侧的值赋值给左侧的变量;

   ​	 ||= 的意思是，如果左侧的值是假值(六大假值)，就把右侧的值赋值给左侧的变量。因为此时左侧如果是真值，就会跳过右侧;

   ​	 &&= 的意思是，如果左侧的值是真值(假值之外的就是真值)，就把右侧的值赋值给左侧的变量。

5. **数值分隔符**：对于数字，比如123456789，一长串看起来很累，所以这次加了下划线作为分隔符（`_`），主要是方便阅读(其他语言也有类似的分隔符)，对数字本身的大小没有影响。注意，下划线不能连续，也不能放在开头和结尾，放在开头，就变成字符串了，会被当成变量名，放在结尾会直接报语法错误。

## 了解更多

TC39 官网：https://github.com/tc39/

提案：https://github.com/tc39/proposals

TC39 中文站：https://jscig.github.io/

参与中文讨论：https://github.com/JSCIG/es-discuss/discussions
