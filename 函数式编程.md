# 真实的高阶函数

## every函数

~~~javascript
const every = (arr, fn) => {
  let result = true
  for (let i = 0; i < arr.length; i++) {
    result=result && fn(arr[i])
  }
  return result
 }
~~~

~~~javascript
const every = (arr, fn) => {
  let result = true
  for (const value of arr) {
    result=result && fn(value)
  }
  return result
 }
~~~

## some函数

~~~javascript
const every = (arr, fn) => {
  let result = false
  for (const value of arr) {
    result=result || fn(value)
  }
  return result
 }
~~~

## sort函数

arr.sort([compareFunction])

~~~javascript
compare函数的骨架
functon compare(a, b){ 
  if (根据某种排序标准a小于b) { 
    return -1
  }
  if (根据某种排序标准a大于b) { 
    return 1
  }
  // a一定等于b
  return 0
}
~~~

~~~javascript
const sortBy = (property) => {
  return (a, b) => {
    var result = (a[property] < b[property]) ? -1 : (a[property] > b[property]) ? 1 : 0)
    return result
   }
 }
people.sort(sortBy("firstname"))
~~~

# 闭包与高阶函数

## 闭包

闭包：闭包就是一个内部函数，它是另一个函数内部的函数。

从技术上讲，闭包有3个可访问的作用域：

（1）在它自身声明之内声明的变量

（2）对全局变量的访问

（3）对外部函数变量的访问   

## 高阶函数

## unary函数

~~~javascript
const unary = (fn) =>fn.length===1?fn:(arg)=>fn(arg)
let arr = ['1', '2', '3'].map(unary(parseInt))
~~~

在JavaScript中，（exp1，exp2）的含义是它将执行两个参数并返回第二个表达式的结果，即exp2。

函数形参的长度可以通过函数的length属性查看。

## once函数

只运行一次给定的函数。

~~~javascript
const once = (fn) => {
  let done = false
  return function () {
    return done?undefined:((done=true),fn.apply(this,arguments))
  }
 }
~~~

## memoized函数

~~~javascript
阶乘
var factorial = (n) => {
  if (n === 0) {
    return 1
  }
  return n*factorial(n-1)
}
输入存储结果
const memoized = (fn) => {
  const lookupTable = {}
  return (arg)=>lookupTable[arg] || (lookupTable[arg]=fn(arg))
}
memoized函数
let fastFactorial = memoized((n) => {
  if (n === 0) {
    return 1
  }
  return n*fastFactorial(n-1)
})
~~~

# 数组的函数式编程

## forEach

~~~javascript
const forEach=(array,fn)=>{
    for(const value of array){
        fn(value)
    }
}
~~~

## map

~~~javascript
const map=(array,fn)=>{
    let results=[]
    for(const value of array){
        results.push(fn(value))
    }
    return results
}
~~~

## filter

~~~javascript
const filter=(array,fn)=>{
    let results=[]
    for(const value of array){
        (fn(value))?results.push(value):undefined
    }
    return results
}
~~~

##  reduce：累计器

~~~javascript
const reduce=(array,fn)=>{
    let accumlator=0
    for(const value of array){
        accumlator=fn(accumlator,value)
    }
    return accumlator
}
reduce(array,(acc,val)=>acc+val)
~~~

~~~javascript
const reduce=(array,fn,initialValue)=>{
    let accumlator
    if(initialValue!==undefined){
        accumlator=initialValue
    }else{
        accumlator=array[0]
    }
    if(initialValue===undefined){
        for(let i=1;i<array.length;i++){
            accumlator=fn(accumlator,arrary[i])
        }
    }else{
        for(const value of array){
            accumlator=fn(accumlator,value)
        }
    }
    return accumlator
}
~~~

## zip函数：合并给定的两个数组

~~~javascript
const zip=(leftArr,rightArr,fn){
    let index,results=[]
    for(index=0;index<Math.min(leftArr.length,rightArr.length);index++){
        results.push(fn(leftArr[index],rightArr[index]))
    }
    return results
}
~~~

# 柯里化与偏应用

柯里化：柯里化是把一个多参函数转换为一个嵌套的一元函数的过程。

~~~javascript
// 把多参函数转换为一元函数的curry函数
let curry = (fn) => {
  if (typeof fn !== 'function') {
    throw Error('No function provided')
  }
  return function curriedFn(...args) {
    if (args.length < fn.length) {
      return function () {
        console.log('xxxx',args,arguments)
        return curriedFn.apply(null,args.concat([...arguments]))
      }
    }
    return fn.apply(null,args)
  }
}
const multiply = (x, y, z) => x * y * z
console.log(curry(multiply)(3)(2)(1)) //6
~~~

偏应用

~~~javascript
const partial = function (fn, ...partialArgs) {
  let args = partialArgs
  return function (...fullArguments) {
    let arg = 0
    for (let i = 0; i < args.length && arg < fullArguments.length; i++) {
      if (args[i] === undefined) {
        args[i]=fullArguments[arg++]
      }
    }
    return fn.apply(null,args)
   }
}
let delayTenMs = partial(setTimeout, undefined, 10)
delayTenMs(()=>console.log("Do Y task"))
~~~

如果API如map、filter一样定义，就可以轻松地使用curry函数解决问题。可能存在不是为curry函数设计的函数，比如例子中的setTimeout，在这种情况下，最合适的选择是使用偏函数。

# 组合与管道

组合的数据流是从右到左，管道的数据流是从左到右。

## 组合

组合函数

~~~javascript
const compose = (a, b) => {
  return (c) => {
    return a(b(c))
   }
 }
// 对给定的字符串数字四舍五入求值
let number=compose(Math.round,parseFloat)
number("3.56")
~~~

curry与partial与组合函数

~~~javascript
// 过滤函数
let filterOutStandingBooks=(book)=>book.rating[0]===5
let filterGoodBooks=(book)=>book.rating[0]>4.5
let filterBadBooks=(book)=>book.rating[0]<3.5
// 投影函数
let projectTitleAndAuthor=(book)=>{
    return{
        title:book.title,
        author:book.author
    }
}
let projectAuthor=(book)=>{
    return{
         author:book.author
    }
}
let projectTitle=()=>{
     title:book.title
}
// 获取评级高于4.5的图书的标题和作者
let queryGoodBooks=partial(filter,undefined,filterGoodBooks)
let mapTitleAndAuthor=partial(map,undefined,projectTitleAndAuthor)
let titleAndAuthorForGoodBooks=compose(mapTitleAndAuthor,queryGoodBooks)
titleAndAuthorForGoodBooks(apressBooks) //apressBooks是书的数组
~~~

组合多个函数

~~~javascript
const compose=(...fns)=>{
   return  (value)=>{
        return reduce(fns.reverse(),(acc,fn)=>fn(acc),value)
    }
}
~~~

## 管道

~~~javascript
const pipe=(...fns)=>{
    return (value)=>{
        return reduce(fns,(acc,fn)=>fn(acc),value)
    }
}
~~~

使用tap函数调试

~~~javascript
const identity=(it)=>{
    console.log(it)
    return it
}
// 使用
compose(count,identity,splitIntoSpaces)("Test string")
~~~

# 函子

函子是一个普通对象（在其他语言中，可能是一个类），它实现了map函数，在遍历每个对象值的时候生成一个新对象。

~~~javascript
const Container=function(val){
    this.value=val
}
Container.of=function(value){
    return new Container(value)
}
Container.prototype.map=function(fn){
    return Container.of(fn(this.value))
}
let double=(x)=>x+x
Container.of(3).map(double) // Contanier {value:6}
~~~

## MayBe函子

利用函数式编程处理错误或异常问题

~~~javascript
const MayBe = function (val) {
  this.value=val
}
MayBe.of = function (val) {
  return new MayBe(val)
}
MayBe.prototype.isNothing = function () {
  return (this.value===null || this.value===undefined)
}
MayBe.prototype.map = function (fn) {
  return this.isNothing()?MayBe.of(null):MayBe.of(fn(this.value))
}
MayBe.of("George").map(() => undefined).map(x => "Mr. " + x) // MayBe { value: null }
~~~

## Either函子

它能够解决分支拓展问题

~~~javascript
const Nothing = function (val) {
  this.value=val
}
Nothing.of = function (val) {
  return new Nothing(val)
}
Nothing.prototype.map=function(f){
    return this
}
const Some=function(val){
    this.value=val
}
Some.of=function(value){
    return new Some(value)
}
Some.prototype.map=function(fn){
    return Some.of(fn(this.value))
}
// Some封装了正确的响应，Nothing封装了错误的响应
let post=(type)=>{
    let response
    try{
        response=Some.of(请求接口的数据)
    }catch(err){
        respose=Nothing.of({message:'错误'})
    }
   return response
}
let data=(type)=>{
    let reponse=post(type)
    return reponse.map().map()
}
data('new')
// 如果是错误的话，会一直返回Nothing，映射也不会执行；如果是正确的会返回Some，映射会执行
~~~

# 深入理解Monad

多个map问题

~~~javascript
MayBe.prototype.join=function(){
    return this.isNothing()?MayBe.of(null):this.value
}
let joinExample=MayBe.of(MayBe.of(5))
joinExample.join().map((v)=>v+4)
MayBe.prototype.chain=function(f){
    return this.map(f).join()
}
// chain函数的作用是再执行一次map并返回本身
~~~